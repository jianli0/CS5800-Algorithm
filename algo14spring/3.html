
<!-- saved from url=(0180)https://s3.amazonaws.com/piazza-resources/hq6zhmpv89t5lx/hr6pglz54uc3lj/asst3.html?AWSAccessKeyId=AKIAJKOQYKAYOBKKVTKQ&Expires=1415662434&Signature=5p5YvtFP5Qf0Rj%2FgVk2ZptB0Rrs%3D -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>CS5800 Algorithms Spring 2014</title>
<style type="text/css">#yddContainer{display:block;font-family:Microsoft YaHei;position:relative;width:100%;height:100%;top:-4px;left:-4px;font-size:12px;border:1px solid}#yddTop{display:block;height:22px}#yddTopBorderlr{display:block;position:static;height:17px;padding:2px 28px;line-height:17px;font-size:12px;color:#5079bb;font-weight:bold;border-style:none solid;border-width:1px}#yddTopBorderlr .ydd-sp{position:absolute;top:2px;height:0;overflow:hidden}.ydd-icon{left:5px;width:17px;padding:0px 0px 0px 0px;padding-top:17px;background-position:-16px -44px}.ydd-close{right:5px;width:16px;padding-top:16px;background-position:left -44px}#yddKeyTitle{float:left;text-decoration:none}#yddMiddle{display:block;margin-bottom:10px}.ydd-tabs{display:block;margin:5px 0;padding:0 5px;height:18px;border-bottom:1px solid}.ydd-tab{display:block;float:left;height:18px;margin:0 5px -1px 0;padding:0 4px;line-height:18px;border:1px solid;border-bottom:none}.ydd-trans-container{display:block;line-height:160%}.ydd-trans-container a{text-decoration:none;}#yddBottom{position:absolute;bottom:0;left:0;width:100%;height:22px;line-height:22px;overflow:hidden;background-position:left -22px}.ydd-padding010{padding:0 10px}#yddWrapper{color:#252525;z-index:10001;background:url(chrome-extension://ibogfemlnclpecapkojhmanpiebldbnk/ab20.png);}#yddContainer{background:#fff;border-color:#4b7598}#yddTopBorderlr{border-color:#f0f8fc}#yddWrapper .ydd-sp{background-image:url(chrome-extension://ibogfemlnclpecapkojhmanpiebldbnk/ydd-sprite.png)}#yddWrapper a,#yddWrapper a:hover,#yddWrapper a:visited{color:#50799b}#yddWrapper .ydd-tabs{color:#959595}.ydd-tabs,.ydd-tab{background:#fff;border-color:#d5e7f3}#yddBottom{color:#363636}#yddWrapper{min-width:250px;max-width:400px;}</style></head>
<body>
<center><h1>CS5800 Algorithms Spring 2014 Assignment #3</h1></center>
<p>

In the union algorithm, when combining trees which cannot otherwise be
distinguished (such as being of the same rank), the new root should be from the
tree specified by the first parameter to union.

</p><p>

1. (12 points) Run the union-find algorithm using union with ranks on the following set of edges in the order given:
<table cellpadding="5">
<tbody><tr><td>(1,15)</td><td>(6,17)</td><td>(10,19)</td><td>(1,2)</td><td>(2,12)</td><td>(17,15)</td><td>(7,13)</td><td>(19,3)</td><td>(4,7)</td><td>(4,3)</td><td>(17,13)
</td></tr></tbody></table>
</p><p>
Show what the forest looks like after each step.
Note: Do not use path compression.
</p><p>

2. (16 points) Simultaneously run the DFS algorithm and union-find with path compression on the following directed graph.
Union is performed just before calling explore recursively in the loop over the adjacent edges.
Each vertex has a parent pointer for the union-find algorithm.  
When there is a choice for the next vertex, use the one that is smaller
numerically. Show all steps
<table cellpadding="5">
<tbody><tr><td>(1,5)</td><td>(1,6)</td><td>(2,4)</td><td>(3,1)
</td></tr><tr><td>(6,3)</td><td>(7,9)</td><td>(9,3)</td><td>(10,8)
</td></tr><tr><td>(10,11)</td><td>(11,8)</td><td>(11,10)
</td></tr></tbody></table>
</p><p>

3. (12 points) Add the following three edges to the graph in Problem #2 above:
(1,10), (8,7) and (9,2).  Run BFS on the resulting directed graph, starting
with vertex 1. Show every step.

</p><p>

4. (25 points) Prove Tarjan's second path property. Show all of the details.
In particular, be sure to show the details for the induction.

</p><p>

5. (20 points) Show what happens when Tarjan's strongly-connected component algorithm is applied to the following directed graph:
<table cellpadding="5">
<tbody><tr><td>(1,8)</td><td>(2,4)</td><td>(2,6)</td><td>(3,1)
</td></tr><tr><td>(3,5)</td><td>(4,1)</td><td>(4,10)</td><td>(5,3)
</td></tr><tr><td>(5,7)</td><td>(6,4)</td><td>(7,5)</td><td>(7,9)
</td></tr><tr><td>(8,2)</td><td>(9,10)</td><td>(10,9)
</td></tr></tbody></table>
</p><p>
Use the technique explained in class. Show how the strongly-connected components "grow" as the DFS algorithm proceeds.
In other words, as each edge is processed by the DFS algorithm, show what the strongly-connected components are
up to that point in the algorithm. Also show what happens as one goes from one step to the next, and explain why it happens.

</p><p>

6. (15 points) A social networking site allows people to "like" other people.
The site automatically specifies that every person likes him/herself.
If a person A likes person B, it need not be the case that person B likes person A.
However, if person A likes person B and person B likes person C, then person A likes person C.
A "clique" is a set of people who like each other (i.e., everyone likes everyone else in the set).
Using pseudo-code, develop an algorithm that finds all of the maximimal cliques on the social networking site.
Your algorithm must be linear in the number of like relationships on the site.
Prove that your algorithm is linear.



</p></body></html>